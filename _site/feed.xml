<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Um tanto quanto curioso</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 01 Dec 2020 15:17:48 -0300</pubDate>
    <lastBuildDate>Tue, 01 Dec 2020 15:17:48 -0300</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Automatizando tarefas com o WhatsApp</title>
        <description>&lt;p&gt;Heeeey, tudo bem contigo? Estou muito animado com essa dica de hoje, porque eu amo esse tipo de projeto. Espero que voc√™ curta essa &lt;strong&gt;experi√™ncia&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;splash projects&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;span class=&quot;title&quot;&gt;J√° manja de Node.js?&lt;/span&gt;
        &lt;span class=&quot;description&quot;&gt;Ent√£o talvez voc√™ prefira ir direto para o c√≥digo do projeto.&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;btn&quot;&gt;
        &lt;a href=&quot;https://github.com/pedroentringer/bot-whatsapp-services&quot; target=&quot;_blank&quot;&gt;Ver o Projeto&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/f2c98102-23ed-45b9-a60a-00f89b8dfe0c.jpeg&quot; style=&quot;width: 200px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ent√£o vamos direto ao que interessa!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Recentemente uma turma lan√ßou uma biblioteca simplesmente &lt;strong&gt;sensacional&lt;/strong&gt; que nos permite explorar &lt;strong&gt;demais&lt;/strong&gt; as funcionalidades do WhatsApp Web usando seu WebPack. A lib ficou incrivelmente profissional e simples de usar.&lt;/p&gt;

&lt;p&gt;O pacote chama-se &lt;strong&gt;whatsapp-web.js&lt;/strong&gt; e voc√™ pode conferir toda documenta√ß√£o &lt;a href=&quot;https://waguide.pedroslopez.me/&quot; title=&quot;whatsapp-web.js&quot;&gt;clicando aqui&lt;/a&gt;, e o github &lt;a href=&quot;https://github.com/pedroslopez/whatsapp-web.js&quot; title=&quot;whatsapp-web.js&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&quot;bora-codar&quot;&gt;Bora Codar&lt;/h5&gt;
&lt;p&gt;J√° crie um projeto por ai, com essa estrutura:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/6f208174-0592-4142-a5f1-360e2f4b2554.png&quot; alt=&quot;Estrutura de Pastas&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;pacotes&quot;&gt;Pacotes&lt;/h6&gt;
&lt;p&gt;Neste projeto iremos utilizar os seguintes pacotes, ent√£o inicie seu projeto com a estrutura acima e instale os pacotes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sucrase&lt;/li&gt;
  &lt;li&gt;whatsapp-web.js&lt;/li&gt;
  &lt;li&gt;@pedroentringer/parser-command-line&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn init -y
$ yarn add sucrase whatsapp-web.js @pedroentringer/parser-command-line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como iremos utilizar o &lt;strong&gt;sucrase&lt;/strong&gt; aqui para poder escrever com import/export vamos criar um script de start no &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;bot-whatsapp&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;sucrase-node src/index.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@pedroentringer/parser-command-line&quot;: &quot;^1.0.1&quot;,
    &quot;sucrase&quot;: &quot;^3.15.0&quot;,
    &quot;whatsapp-web.js&quot;: &quot;^1.6.0&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show, feito isso vamos para o nosso arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; dentro da pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; e j√° iniciar nosso bot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo o Client do pacote
import { Client } from 'whatsapp-web.js'

/**
 * Crio o client, e √© aqui que ele ir√° abrir o navegador de forma oculta usando puppeteer
 *
 * Porem aqui eu quero poder ler o QRCode pelo navegador sempre que for a primeira execu√ß√£o
 * para que assim eu n√£o precise fazer isso pelo terminal ent√£o eu passo o headless como false
 */
const client = new Client({
  puppeteer: {
    headless: false
  }
})

//Escuto o evento ready que √© disparo quando o navegador abre o whatsapp corretamente
client.on('ready', () =&amp;gt; console.log('Client is ready!'))

//Escuto o evento message que √© disparado quando o whatsapp recebe uma nova mensagem
client.on('message', message =&amp;gt; console.log(message))

//inicializo o client para que tudo comece a rodar
client.initialize()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show de bola, se voc√™ rodar isso j√° vai conseguir ver seu navegador abrindo. Dai voc√™ vai precisar scanear o QRCode para acessar o WhatsApp.
Feito isso, sempre que receber uma nova mensagem ela ira aparecer no seu terminal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E olha que irado&lt;/strong&gt;, voc√™ j√° consegue receber todas as mensagens direto no c√≥digo, sensacional n√©? Fa√ßa voc√™ mesmo, rode esse comando no seu terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn start&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;executando-comandos&quot;&gt;Executando comandos&lt;/h3&gt;
&lt;p&gt;Esse sisteminha vai rodar em um Windows Server, ent√£o todos os meus comandos Shell aqui ser√£o para Win. &lt;strong&gt;Mas n√£o se preocupe&lt;/strong&gt;, voc√™ poder√° usar outros comandos de acordo com seu servidor.&lt;/p&gt;

&lt;p&gt;O Node.js tem por padr√£o um carinha chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; que voc√™ pode importar do pacote &lt;code class=&quot;highlighter-rouge&quot;&gt;child_process&lt;/code&gt; e √© exatamente ele que iremos usar para rodar nossos comandos. Nele voc√™ consegue executar scripts como se estivesse no terminal/cmd da sua m√°quina.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Shell.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo o exec do node
import { exec } from 'child_process'

//crio uma classe pra controlar todos os comandos
export default class Shell {

  /** 
   * Defino uma function chamada restart que ir√° reiniciar alguns servi√ßos
   * Perceba que ela recebe os parametros que s√£o tratados pela lib @pedroentringer/parser-command-line
   */
  async restart ({ commands, flags }) {
    for (const command of commands) {
      
      /**
        * Se o comando for igual a &quot;cte&quot; vou matar o servi√ßo que est√° rodando atualmente e rodar ele novamente
        */
      if (command === 'cte') {
        this.executeCommands([
          'taskkill /f /im cmd.exe /fi &quot;windowtitle eq CTE&quot;',
          'taskkill /f /im apagt_cte_nfe.exe',
          'start &quot;&quot; &quot;C:\\Users\\pedro.iconex\\Desktop\\CTE.bat&quot;'
        ])
      }

      /**
        * Se o comando for igual a &quot;email&quot; vou parart as services respons√°veis por isso e inici√°-las novamente
        */
      if (command === 'email') {
        await this.executeCommands([
          'net stop apiintegracaoemailxml.exe',
          'net start apiintegracaoemailxml.exe',
          'net stop apiintegracaoemailedi.exe',
          'net start apiintegracaoemailedi.exe'
        ])
      }
    }
  }

  async run ({ commands, flags }) {
    for (const command of commands) {
      /**
        * Se o comando for igual a &quot;cte&quot; eu executo um start &quot;C:\\Users\\pedro.iconex\\Desktop\\CTE.bat&quot; em meu CMD.
        */
      if (command === 'cte') {
        this.executeCommand('start &quot;&quot; &quot;C:\\Users\\pedro.iconex\\Desktop\\CTE.bat&quot;')
      }

      /**
        * Se o comando for igual a &quot;cte&quot; eu executo um start &quot;D:\\API_NODE\\util\\ajustes\\corrigeIBGE.js&quot; em meu CMD.
        */
      if (command === 'ibge') {
        await this.executeCommand('node &quot;D:\\API_NODE\\util\\ajustes\\corrigeIBGE.js&quot;')
      }

    }
  }

  /**
   * Essa fun√ß√£o vai receber um array de comandos e executar um de cada vez.
   */
  async executeCommands (commands) {
    for (const command of commands) {
      await this.executeCommand(command)
    }
  }

  /**
   * Essa fun√ß√£o recebe a string do comando e executa usando o &quot;exec&quot; do node
   */
  executeCommand (command) {
    return new Promise((resolve, reject) =&amp;gt; {
      exec(command, (error, stdout, stderr) =&amp;gt; {
        if (error) reject(error)
        if (stderr) reject(stderr)
        resolve('Success')
      })
    })
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uma outra coisa interessante desse &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; √© que a vari√°vel &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt; retorna exatamente tudo que for imprimido no terminal, dai voc√™ pode tratar isso de alguma forma se for necess√°rio.&lt;/p&gt;

&lt;p&gt;Show de bola, at√© aqui n√≥s j√° recebemos as mensagem e temos a classe respons√°vel por executar os comandos.&lt;/p&gt;

&lt;p&gt;Mas antes de utilizar, vamos criar alguns alertas pop-up em nosso bot para que fique mais f√°cil de entender o que est√° acontecendo quando ele estiver em segundo plano.&lt;/p&gt;

&lt;h3 id=&quot;criando-alertas&quot;&gt;Criando Alertas&lt;/h3&gt;
&lt;p&gt;Eu gosto de pensar que esses scripts precisam ser ocultos, ent√£o costumo exibir um alerta na tela quando o programa inicia com sucesso ou apresenta algum erro.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Alert.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import Shell from './Shell'
const shell = new Shell()

export default class Alert {
  static showAlert (title, message) {
    const { platform } = process
    if (platform === 'darwin') this.showAlertDarwin(title, message)
    if (platform === 'win32') this.showAlertWin(title, message)
  }

  static showAlertDarwin (title, message) {
    /**
     * Repare que iremos usar nossa classe Shell para executar um script no terminal
     * Esse script exibe um pop-up no MacOs
     */
    shell.executeCommand(`osascript -e 'display notification &quot;${message}&quot; with title &quot;${title}&quot;'`)
  }

  static showAlertWin (title, message) {
    /**
     * Repare que iremos usar nossa classe Shell para executar um script no terminal
     * Esse script exibe um pop-up no Windows
     */
    shell.executeCommand(`msg %username% &quot;${title} ${message}&quot;`)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show feito isso, n√≥s j√° receberemos os alertas em pop-up sempre que o bot iniciar. Aqui eu s√≥ consegui testar com Mac e Win. Ent√£o provavelmente para o linux voc√™ precisar√° adaptar esse comando.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/6daa59c1-25a5-40b6-b157-f5d22e252a76.png&quot; alt=&quot;Estrutura de Pastas&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;gravando-sess√£o-do-whatsapp&quot;&gt;Gravando Sess√£o do WhatsApp&lt;/h3&gt;
&lt;p&gt;O problema que temos agora √© que sempre que voc√™ inicia o bot √© necess√°rio ficando lendo aquele QRCode novamente. Isso √© bem chato n√©? Imagine um &lt;strong&gt;shutdown&lt;/strong&gt; n√£o programado do servidor, seu bot iria parar de funcionar e voc√™ nem saberia.&lt;/p&gt;

&lt;p&gt;O pessoal da lib pensou nisso, e nos permitem salvar a sess√£o gerada pelo WhatsApp, maravilhoso n√©?&lt;/p&gt;

&lt;p&gt;Pra fazer isso, vamos criar um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Session.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt;, esse arquivo ser√° uma classe que controlar essa sess√£o.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo a lib &quot;fs&quot; do node que me permitira ler e gravar arquivos
import * as fs from 'fs'

//importo a fun√ß√£o &quot;resolve&quot; da lib &quot;path&quot; pra poder resolver um diret√≥rio
import { resolve } from 'path'

//importo nosso alerta, pra disparar as mensagems de sucesso ou erro
import Alert from './Alert'

//resolvo o caminho que irei salvar a sess√£o
const sessionPath = resolve(__dirname, '..', 'config', 'session.json')

//crio a classe Session
export default class Session {

  //crio uma fun√ß√£o para salvar o conteudo da sess√£o em JSON
  static save (session) {
    fs.writeFile(
      sessionPath,
      JSON.stringify(session),
      async (error) =&amp;gt; error &amp;amp;&amp;amp; Alert.showAlert('[BOT] Pedro Entringer', error.message)
    )
  }

  //crio uma fun√ß√£o para ler o JSON da sess√£o
  static get () {
    if (fs.existsSync(sessionPath)) {
      return require(sessionPath)
    }

    return undefined
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pronto! Assim que vincularmos isso ao bot voc√™ vera que ser√° criado um arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;session.json&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/config&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lembre-se de criar essa pasta&lt;/strong&gt;, se n√£o o c√≥digo n√£o ir√° funcionar.&lt;/p&gt;

&lt;h3 id=&quot;criando-o-bot-de-fato&quot;&gt;Criando o Bot de Fato&lt;/h3&gt;
&lt;p&gt;J√° temos tudo que √© preciso para executar os comandos em nosso servidor, certo? &lt;strong&gt;Sim.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;J√° estamos recebendo as mensagens do WhatsApp, certo? &lt;strong&gt;Sim.&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;ent√£o-o-que-falta-agora&quot;&gt;Ent√£o o que falta agora?&lt;/h5&gt;
&lt;p&gt;Hehehe, agora precisamos entender a mensagem que est√° chegando do WhatsApp para saber qual comando vamos executar.&lt;/p&gt;

&lt;p&gt;E vamos fazer isso usando a lib &lt;code class=&quot;highlighter-rouge&quot;&gt;@pedroentringer/parser-command-line&lt;/code&gt; de forma bastante simples.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Bot.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo a lib para fazer um parse nas mensagens
import { parseString } from '@pedroentringer/parser-command-line'

//import nosso shell
import Shell from './Shell'

//inicio o shell
const shell = new Shell()

//crio uma classe bot
export default class Bot {

  /**
   * Defino seu construtor recebendo o client do WhatsApp 
   * para que eu possa responder as mensagems por aqui.
   */
  constructor (client) {
    this.client = client

    /**
     * Defino um contato, pois eu desejo que apenas ele possa me enviar mensagems.
     * Alias, este √© o meu contato, mude para o seu aqui.
     */
    this.contact = '5527981670051@c.us'
  }

  //crio uma fun√ß√£o para validar se quem est√° mandando a mensagem √© o contato que definimos
  isAdmin (contact) {
    if (!this.client) throw new Error('Client is not ready!')

    if (contact !== this.contact) throw new Error('Client is not ready!')
  }

  /**
   * Essa fun√ß√£o recebe a mensagem e quem enviou
   * body =&amp;gt; Mensagem
   * from =&amp;gt; Quem enviou
   */
  async parseMessage ({ body, from }) {
    
    //valido se quem enviou a mensagem √© o nosso contato
    this.isAdmin(from)

    //fa√ßo o parse da mensagem
    const { bin, commands, flags } = parseString(body)

    //defino quais s√£o os &quot;bins&quot; aceitos pelo bot
    const availlableBins = ['restart', 'run', 'commands']

    //valido os bins
    if (availlableBins.find(availlableBin =&amp;gt; availlableBin === bin)) {
      try {

        //direciono os comandos e as flags baseado no bin recebido
        if (bin === 'commands') await this.showCommands(from)
        if (bin === 'restart') await shell.restart({ commands, flags })
        if (bin === 'run') await shell.run({ commands, flags })

        //se tudo ocorrer corretamente, respondo com sucesso.
        if (bin !== 'commands') await this.client.sendMessage(from, '‚úÖ Command successfully executed')
      } catch (err) {

        //se houver erro respondo com o detalhe do erro.
        await this.client.sendMessage(from, `‚ö†Ô∏è ${err.message}`)
      }
    } else {

      //Se n√£o for um comando v√°lido
      await this.client.sendMessage(from, 'üôÅ This is not a valid command.')
    }
  }

  //lista os comandos v√°lidos
  async showCommands (from) {
    await this.client.sendMessage(from, 'üöÄ List of commands')
    await this.client.sendMessage(from, '*run [{programs}]*\nUsed to run some system services.\nAvailable: cte, sefaz, ibge and ie')
    await this.client.sendMessage(from, '*restart [{programs}]*\nUsed to restart some system services.\nAvailable: cte and email')
    await this.client.sendMessage(from, '*commands*\nUsed to list all accepted commands.')
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sensacional! Isso j√° √© suficiente para nosso Bot funcionar &lt;strong&gt;perfeitamente&lt;/strong&gt;, vamos liga-lo?&lt;/p&gt;

&lt;h3 id=&quot;toque-final&quot;&gt;Toque final&lt;/h3&gt;
&lt;p&gt;Criamos todas nossas classes principais, s√≥ precisamos agora √© vincular elas de fato com nosso &lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt; do bot.&lt;/p&gt;

&lt;p&gt;Para fazer isso, vamos modificar nosso arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;, e faremos da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { Client } from 'whatsapp-web.js'

//importo todas as noosas classes
import Bot from './components/Bot'
import Alert from './components/Alert'
import Session from './components/Session'

//crio o client
const client = new Client({
  puppeteer: {
    headless: !!Session.get() //aqui eu valido se existe uma sessao, para saber se eu devo exibir o navegado ou n√£o
  },
  session: Session.get() //busco a sess√£o existente
})

//inicio o bot
const bot = new Bot(client)

//exibo o alerta quando o bot estiver pronto para usi
client.on('ready', () =&amp;gt; Alert.showAlert('[BOT] Pedro Entringer', 'Client is ready!'))

//salvo a sess√£o quando fizermos a primeira leitura do QRCode
client.on('authenticated', (session) =&amp;gt; Session.save(session))

//mando as mensagens recebidas para o nosso Bot
client.on('message', message =&amp;gt; bot.parseMessage(message))

//inicializo o client do WhatsApp Web
client.initialize()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana n√©? E voc√™ pode aplicar isso em diversas outras funcionalidades. Aqui n√£o existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 May 2020 19:50:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/automatizando-tarefas-com-o-whatsapp/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/automatizando-tarefas-com-o-whatsapp/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Criando seu plugin para Google Chrome</title>
        <description>&lt;p&gt;Heeeey, j√° vimos que na internet tem vaaaarios tutoriais sobre este tema, n√£o √© mesmo?
Vamos pra mais um, s√≥ que dessa vez, sem &lt;strong&gt;pop-up&lt;/strong&gt; hahaha.&lt;/p&gt;

&lt;p&gt;Ah, e esse plugin vai funcionar no Google Chrome, Opera e no novo Edge.&lt;/p&gt;

&lt;p&gt;O que n√≥s vamos fazer por aqui √© explorar aquele menu que aparece nos sites quando clicamos com o bot√£o direito do mouse. Iremos criar uma op√ß√£o para compartilhar um texto selecionado com algum contato do &lt;strong&gt;WhatsApp&lt;/strong&gt; que for definido no script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/5d73b650-3a82-4487-b133-a66217e0a7a7.png&quot; alt=&quot;Menu do navegador&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lets-go-to-code&quot;&gt;Let‚Äôs go to code&lt;/h3&gt;
&lt;p&gt;Vamos iniciar nosso projeto com uma pasta em branco, e nela criaremos o primeiro arquivo chamado &lt;strong&gt;manifest.json&lt;/strong&gt;. Este arquivo contem todos os detalhes de nossa extens√£o e eu vou explicar os mais importantes agora.&lt;/p&gt;

&lt;p&gt;Vamos colocar nele essas configura√ß√µes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;background&quot;: {
    &quot;persistent&quot;: false,
    &quot;scripts&quot;: [&quot;src/index.js&quot;]
  },
  &quot;browser_action&quot;: {
    &quot;default_title&quot;: &quot;Compartilhamento do Pedro&quot;,
    &quot;default_icon&quot;: &quot;icon.png&quot;
  },
  &quot;icons&quot;: {
      &quot;128&quot;: &quot;icon.png&quot;,
      &quot;16&quot;: &quot;icon.png&quot;,
      &quot;32&quot;: &quot;icon.png&quot;,
      &quot;48&quot;: &quot;icon.png&quot;
  },
  &quot;description&quot;: &quot;Compartilhar frases e sites&quot;,
  &quot;manifest_version&quot;: 2,
  &quot;name&quot;: &quot;Compartilhamento do Pedro&quot;,
  &quot;permissions&quot;: [&quot;contextMenus&quot;],
  &quot;short_name&quot;: &quot;Compartilhamento do Pedro&quot;,
  &quot;version&quot;: &quot;0.1&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos ver melhor o que significa isso:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;background&lt;/strong&gt;: aqui ficam as configura√ß√µes de segundo plano, ou seja, aquilo que vai acontecer por tras da tela.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;persist&lt;/strong&gt;: definimos que n√£o vamos salvar nada, ou seja, n√£o iremos persistir nenhum dado.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;scripts&lt;/strong&gt;: e aqui vem o principal, ser√£o os nossos arquivos de javascript que ir√£o manipular o menu.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;browser_action&lt;/strong&gt;: aqui ficam as configura√ß√µes mais visuais como icone e titulo que ir√£o aparecer no menu.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;permissions&lt;/strong&gt;: Este passo √© muito importante, pois sempre precisaremos deixar claro as permiss√µes que desejamos usar. E para o nosso tutorial precisaremos apenas do &lt;strong&gt;contextMenus&lt;/strong&gt;, mas voc√™ pode ver as outras &lt;a href=&quot;https://support.google.com/chrome/a/answer/7515036?hl=pt-BR&quot; title=&quot;Permiss√µes de Aplicativos e Extens√µes&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Feito isso vamos colocar um icone na extens√£o n√©, e pode ser na raiz do projeto mesmo, no meu caso vou por minha foto de perfil hahahah.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lembre-se&lt;/strong&gt; de colocar o arquivo com o mesmo nome e extens√£o que foi inserido no &lt;strong&gt;manifest.json&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;cad√™-o-c√≥digo&quot;&gt;Cad√™ o c√≥digo?&lt;/h4&gt;
&lt;p&gt;kkkk eu sei, eu sei. Falei demais. &lt;strong&gt;bora codar&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Crie uma pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; e um &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; nela e vamos entender duas coisas. A instala√ß√£o e as funcionalidades.&lt;/p&gt;

&lt;h5 id=&quot;instala√ß√£o&quot;&gt;Instala√ß√£o&lt;/h5&gt;
&lt;p&gt;Sempre que voc√™ instala uma extens√£o o chrome vai executar uma fun√ß√£o chamada &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.runtime.onInstalled&lt;/code&gt;. E √© essa fun√ß√£o que iremos usar para criarmos os nossos menus.&lt;/p&gt;

&lt;p&gt;Pra come√ßar vamos definir quais ser√£o os nossos menus, dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
  {
    id: 'numero01',
    title: 'Compartilhar com a pessoa 01'
  },
  {
    id: 'numero02',
    title: 'Compartilhar com a pessoa 02'
  }
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show, agora vamos entender como vai funcionar esse onInstalled do chrome.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onInstalled = () =&amp;gt; {
  //essa fun√ß√£o vai executar sempre que a extens√£o for instalada
}

chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bom, se j√° temos uma fun√ß√£o que vai ser executada logo de inicio, √© nela que iremos criar nossos menus. E vamos fazer isto usando uma outra fun√ß√£o do chrome que √© a &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.create&lt;/code&gt;, ent√£o vamos percorrer todos os nossos menus e cria-los.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
  {
    id: 'numero01',
    title: 'Compartilhar com a pessoa 01'
  },
  {
    id: 'numero02',
    title: 'Compartilhar com a pessoa 02'
  }
];

const onInstalled = () =&amp;gt; {

  for (const menu of menus) {

    chrome.contextMenus.create({ 
      ...menu, 
      contexts: ['selection'], 
    })
        
  }

}

chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reparou que o &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.create&lt;/code&gt; recebe um &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; como par√¢metro? √â isso que s√£o os menus do chrome hehehe.&lt;/p&gt;

&lt;p&gt;N√≥s ainda passamos um array de &lt;strong&gt;contexts&lt;/strong&gt; pra essa fun√ß√£o, e pra que isso server? √â aqui onde definimos quando o menu aparece. Usando o context &lt;strong&gt;selection&lt;/strong&gt; estamos dizendo que o menu vai aparecer sempre que selecionarmos um texto em algum site e clicarmos com o bot√£o direito.&lt;/p&gt;

&lt;p&gt;Voc√™ pode ver todos os contexts permitidos &lt;a href=&quot;https://developer.chrome.com/apps/contextMenus#type-ContextType&quot; title=&quot;Contexts&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se testarmos essa extens√£o agora, j√° vamos conseguir ver nossos menus por l√°:
&lt;img src=&quot;/assets/images/posts/12028790-eb93-4015-aaee-252a8bf74dc8.png&quot; alt=&quot;Menu do navegador com as nossas op√ß√µes&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;funcionalidade&quot;&gt;Funcionalidade&lt;/h5&gt;
&lt;p&gt;Shoooow, j√° chegamos at√© aqui! Agora √© mole demais!&lt;/p&gt;

&lt;p&gt;Pra adicionar funcionalidade ao clique em nosso menu iremos usar a outra fun√ß√£o do chrome que √© a &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.onClicked&lt;/code&gt; e o nosso c√≥digo vai ficar mais ou menos assim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onClicked = (data, tab) =&amp;gt; {
    const { menuItemId, selectionText} = data
    alert(`Selecionou o texto &quot;${selectionText}&quot; para compartilhar com &quot;${menuItemId}&quot;`)
}

chrome.contextMenus.onClicked.addListener(onClicked)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora sempre que selecionarmos um texto e usarmos nosso compartilhamento o navegador vai mostrar isso em um alerta hehehe
&lt;img src=&quot;/assets/images/posts/e7e74506-a182-4dc7-9983-96078f8cb539.png&quot; alt=&quot;Menu do navegador com as nossas op√ß√µes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas √© s√≥ isso?&lt;/strong&gt; kkkkkk Calma. Vamos de fato compartilhar o texto!&lt;/p&gt;

&lt;p&gt;Ent√£o agora √© simples, j√° temos o texto e o numero da pessoa, ent√£o √© s√≥ fazer o redirect pra url do &lt;strong&gt;WhatsApp&lt;/strong&gt; usando outro recurso do chrome chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.tabs.create&lt;/code&gt; que ir√° criar uma aba no navegador com a url que passarmos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onClicked = (data, tab) =&amp;gt; {
    
    const { menuItemId, selectionText} = data
    
    const resource = new URL(&quot;https://api.whatsapp.com/send&quot;)
    resource.searchParams.append('phone', menuItemId)
    resource.searchParams.append('text', selectionText)

    chrome.tabs.create({ url: resource.href })

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E se voc√™ fez tudo certinho seu plugin j√° estar√° funcionando perfeitamente!!!&lt;/p&gt;

&lt;p&gt;Claro que esse exemplo √© bastante simples, e voc√™ provavelmente n√£o ir√° usar para nada, mas o que vale √© entender o funcionamento de extens√µes do chrome.&lt;/p&gt;

&lt;p&gt;Aqui no trabalho n√≥s usamos uma extens√£o semelhante a essa pra poder consultar pedidos diretamente do e-mail sem precisar ficar abrindo o sistema toda vez. Ah, e a extens√£o foi criada dessa mesma forma.&lt;/p&gt;

&lt;p&gt;O c√≥digo completo ficou assim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
    {
        id: 'pessoa-01',
        title: 'Compartilhar com a pessoa 01'
    },
    {
        id: 'pessoa-02',
        title: 'Compartilhar com a pessoa 02'
    }
];
  
const onInstalled = () =&amp;gt; {

    for (const menu of menus) {

        chrome.contextMenus.create({ 
        ...menu, 
        contexts: ['selection'], 
        })
            
    }

}

const onClicked = (data, tab) =&amp;gt; {

    const { menuItemId, selectionText} = data
    
    const resource = new URL(&quot;https://api.whatsapp.com/send&quot;)
    resource.searchParams.append('phone', menuItemId)
    resource.searchParams.append('text', selectionText)

    chrome.tabs.create({ url: resource.href })

}

chrome.contextMenus.onClicked.addListener(onClicked)
chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana n√©? E voc√™ pode aplicar isso em diversas outras funcionalidades. Aqui n√£o existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 01 May 2020 04:20:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/criando-seu-plugin-para-google-chrome/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/criando-seu-plugin-para-google-chrome/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Trabalhando com argumentos em Node.js</title>
        <description>&lt;p&gt;Voc√™ j√° fez aquele programa que executa uma tarefa espec√≠fica e que funciona perfeitamente, dai de repente surge a necessidade de que esse programa receba um par√¢metro ao iniciar? &lt;strong&gt;Provavelmente sim&lt;/strong&gt;, mas caso ainda n√£o tenha passado por isso, vale a pena aprender pois uma hora voc√™ ir√° acontecer.&lt;/p&gt;

&lt;p&gt;Vamos supor que ele precise receber um CNPJ no in√≠cio do programa, por algum motivo do destino, talvez pra buscar os dados em alguma API. O que importa agora pra gente √© entender como usar os argumentos.&lt;/p&gt;

&lt;p&gt;Naturalmente o Node.js nos permite acessar argumentos no in√≠cio do programa, ent√£o vamos supor que eu deseje passar dois par√¢metros, sendo eles &lt;strong&gt;cnpj&lt;/strong&gt; e &lt;strong&gt;isActive&lt;/strong&gt;, eu faria dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node index 123 true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E l√° no c√≥digo, eu precisaria acessar esses par√¢metros da seguinte maneira:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const cnpj = process.argv[2]
const isActive = Boolean(process.argv[3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Funciona&lt;/strong&gt;? Sim, funciona. Mas voc√™ percebe que tanto a forma de passar esses argumentos quanto a de recebe-los ficou estranha? Talvez n√£o agora, mas no futuro certamente ir√° ser. Imagine uma outra equipe dando manuten√ß√£o nesse c√≥digo dois anos depois.&lt;/p&gt;

&lt;p&gt;Pois √©, eu passei por isso a um tempo atr√°s, e por este motivo fiz a lib &lt;strong&gt;@pedroentringer/parser-command-line&lt;/strong&gt; que simplifica muito este processo.&lt;/p&gt;

&lt;p&gt;Ent√£o vamos instalar esse trem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add @pedroentringer/parser-command-line&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sensacional, feito isso j√° podemos passar e receber argumento de uma forma muito mais simples.
Usando o mesmo exemplo ficaria dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node index --cnpj=123 -isActive&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Melhorou n√©? Agora veja como faremos pra acessar isso no c√≥digo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const parser = require('@pedroentringer/parser-command-line')
const args = parser.parseArgs();

console.log(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que tanto a chamada do script quanto sua escrita ficaram muito mais simples n√©? Eis o resultado disso:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  bin: &quot;node&quot;,
  commands: [&quot;index&quot;],
  flags: {
    cnpj: 123,
    isActive: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dessa forma fica muito melhor pra gente usar estes dados n√£o √© mesmo? E melhor ainda, voc√™ pode usar essa lib na web tamb√©m, dessa forma √© poss√≠vel fazer o parse de um comando vindo de uma string. Pense que a ordem veio via websocket do backend, ou qualquer outro cen√°rio hehehe.&lt;/p&gt;

&lt;p&gt;Usar√≠amos assim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const parser = require('@pedroentringer/parser-command-line')
const args = parser.parseString('meuPrograma show --message=&quot;Que legal, isso √© uma mensagem&quot; --time=100 -isSuccess');

console.log(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e o resultado desse parse ser√°:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  bin: &quot;meuPrograma&quot;,
  commands: [&quot;show&quot;],
  flags: {
    message: &quot;Que legal, isso √© uma mensagem&quot;,
    time: 100,
    isSuccess: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana n√©? E voc√™ pode aplicar isso em diversas outras funcionalidades. Aqui n√£o existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Apr 2020 10:00:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/trabalhando-com-argumentos-em-nodejs/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/trabalhando-com-argumentos-em-nodejs/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Manipulando dados de um site com Web¬†Scraping</title>
        <description>&lt;p&gt;√â impressionante a ideia de conseguir manipular os dados de um site de outra pessoa n√£o √© mesmo? Eu adoro isso, logo quando comecei a faculdade de programa√ß√£o fiquei intrigado por n√£o ser a primeira coisa a aprender (que sonho).&lt;/p&gt;

&lt;p&gt;Mas vamos direto ao ponto, aqui vamos aplicar o Web Scraping em um site simples e em outro um pouco mais complexo. &lt;strong&gt;Let`s go to code&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;bibliotecas-utilizadas&quot;&gt;Bibliotecas utilizadas:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Cheerio&lt;/li&gt;
  &lt;li&gt;@pedroentringer/cheerio-table-parser &lt;strong&gt;(M√°gica kkk)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Axios&lt;/li&gt;
  &lt;li&gt;Puppeteer&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manipulando-dados-de-um-sitesimples&quot;&gt;Manipulando dados de um site¬†simples&lt;/h4&gt;
&lt;p&gt;Pra come√ßar vamos criar nosso projeto bem rapidinho&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn init -y
$ yarn add cheerio axios puppeteer @pedroentringer/cheerio-table-parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este processo pode demorar alguns minutinhos para terminar, enquanto isso vamos falar um pouco sobre cada uma dessas depend√™ncias.&lt;/p&gt;

&lt;h5 id=&quot;axios&quot;&gt;Axios&lt;/h5&gt;
&lt;p&gt;O Axios √© muuuito usado para fazer requisi√ß√µes HTTP, quando voc√™ quer buscar ou enviar dados para algum site.
Por aqui vamos usar ele para buscar a estrutura do meu pr√≥prio blog hehehe&lt;/p&gt;

&lt;h5 id=&quot;cheerio&quot;&gt;Cheerio&lt;/h5&gt;
&lt;p&gt;O Cheerio √© uma lib que nos permite manipular a DOM do site com mais facilidade, muito similar com a forma do JQuery.&lt;/p&gt;

&lt;h5 id=&quot;pedroentringercheerio-table-parser&quot;&gt;@pedroentringer/cheerio-table-parser&lt;/h5&gt;
&lt;p&gt;Essa √© uma lib que eu mesmo fiz pra resolver uma problema que eu tive recentemente. Ela basicamente recebe qualquer tabela em HTML e converte para JSON, assim fica mais f√°cil de manipular os dados n√©? hehehe&lt;/p&gt;

&lt;h5 id=&quot;puppeteer&quot;&gt;Puppeteer&lt;/h5&gt;
&lt;p&gt;O Puppeteer √© incr√≠vel, com ele voc√™ consegue mapear a√ß√µes para que um ‚Äúbot‚Äù replique no site usando um navegador, como se fosse uma pessoa de verdade, &lt;strong&gt;top n√©?&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;lets-go-to-code&quot;&gt;Let‚Äôs go to code&lt;/h5&gt;
&lt;p&gt;Depois que tudo tiver instalado certinho, bora come√ßar de uma forma simples.
O desafio vai ser buscar o titulo do primeiro post desse nosso blog aqui.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar nosso primeiro arquivo &lt;strong&gt;index.js&lt;/strong&gt; e j√° importar o &lt;em&gt;axios&lt;/em&gt; e o &lt;em&gt;cheerio&lt;/em&gt; nele&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const axios = require('axios')
const cheerio = require('cheerio')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Show, feito isso j√° podemos usar o axios para fazer uma busca na home do nosso blog, e vamos fazer isso da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const webscraping = async () =&amp;gt; {

  //Busco os dados no site, e aqui vou receber todo o HTML dele
  const { data } = await axios.get('https://pedroentringer.dev')

  //Importo isso para o cheerio
  const $ = cheerio.load(data)

  //Busco todos os elementos de link &quot;a&quot; que sejam filho de elementos que possuem a classe &quot;post-title&quot; 
  const posts = $('.post-title a')

  //Pego apenas o primeiro elemento
  const firstPost = posts.first()

  //E taraaaam, exibo o texto que tem nesse elemento
  console.log(firstPost.text())

}
webscraping()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E o resultado disso ser√°:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Manipulando dados de um site com Web¬†Scraping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simples n√©? Agora vamos complicar um pouco mais.&lt;/p&gt;

&lt;h4 id=&quot;manipulando-dados-de-um-sitecom-autentica√ß√£o-e-navega√ß√£o&quot;&gt;Manipulando dados de um site¬†com autentica√ß√£o e navega√ß√£o&lt;/h4&gt;
&lt;p&gt;Agora imagine um cen√°rio que voc√™ precise fazer um projeto freelancer pra uma empresa que possui um e-commerce em Magento 1.9, eles precisam visualizar facilmente os 5 pedidos mais populares do site.&lt;/p&gt;

&lt;p&gt;Nesse caso, a cada pagina do painel √© gerado um token diferente, e seria bem chato ficar adivinhando como ele gera esse token para que possamos reproduzir da mesma forma, n√©? Maaas, para resolver isso n√≥s podemos acessar esses dados usando um navegador, e √© ai que entra o puppeteer.&lt;/p&gt;

&lt;p&gt;Vamos l√°, importaremos todas as libs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import cheerio from 'cheerio'
import parseTable from '@pedroentringer/cheerio-table-parser'
import puppeteer from 'puppeteer'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que substitu√≠mos o axios pelo puppeteer.
E agora √© s√≥ abrir o navegador, acessar o site, e &lt;strong&gt;daaaale&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const webscraping = async () =&amp;gt; {

  //Com o puppeteer eu chamo um navegador
  const browser = await puppeteer.launch({
    headless: true //Aqui eu defino se quero que ele apare√ßa ou n√£o =&amp;gt; true (n√£o aparece) | false (aparece)
  })

  try {

    //Crio uma nova aba no navegador
    const page = await browser.newPage()

    //Acesso a pagina de login do painel
    await page.goto('meu_site/admin')

    //Insiro meu email no input de login
    await page.type('input[id=username]', 'oi@pedroentringer.dev')

    //Insiro minha senha no input do login
    await page.type('input[id=login]', 'minha_senha')

    //Clico no bot√£o de Entrar
    await page.click('input[type=submit]')

    /**
    *  Agora eu preciso aguardar o site carregar
    *  e o elemento com id #grid_tab_reviewed_products aparecer na tela
    *  
    *  No painel do Magento 1.9 esse elemento representa um bot√£o que 
    *  ir√° carregar na tela uma tabela com os 5 produtos mais visitados no site
    *  
    *  Assim que ele aparecer eu clico nele
    */
    await page.waitForSelector('#grid_tab_reviewed_products', { visible: true, timeout: 0 })
    await page.click('#grid_tab_reviewed_products')

    /**
    * Apos o clique, preciso esperar nossa tabela aparecer, pois o Magento ir√° fazer um request e buscar esses dados
    */
    await page.waitForSelector('#productsReviewedGrid_table', { visible: true, timeout: 0 })

    /**
    * Perfeito, agora que chegamos aqui, √© como se estivessemos naquele exemplo simples
    * Basta pegar o html da pagina e manipular com o cheerio
    */
    const html = await page.content()

    //Lembre-se sempre de fechar o navegador kkk
    await browser.close()

    //Importo o HTML do site atual para o cheerio
    const $ = cheerio.load(html)
    
    //Ativo o modulo de converter a tabela
    parseTable($)

    //converto a tabela para JSON
    const table = $('#productsReviewedGrid_table').parseTable()

    console.log(table)

  } catch (err) {
    await browser.close()
    console.error(err)
  }
}
webscraping()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O mais legal √© o resultado super f√°cil de manipular, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
  {
    nome: 'Camiseta Infantil Ac/Dc Preta',
    preco: 'R$ 42,90',
    visitas: 185
  },
  {
    nome: 'Body Beatles Yellow Submarine Manga Curta Branco',
    preco: 'R$ 39,90',
    visitas: 178
  },
  {
    nome: 'Body Iron Maiden Manga Curta Preto Algod√£o',
    preco: 'R$ 39,90',
    visitas: 170
  },
  {
    nome: 'Body Manga Curta Chega De Nana Nen√©m Preto',
    preco: 'R$ 39,90',
    visitas: 144
  },
  {
    nome: 'Body Ac/Dc Manga Curta Preto',
    preco: 'R$ 39,90',
    visitas: 141
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana n√©? E voc√™ pode aplicar isso em diversas outras funcionalidades. Aqui n√£o existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Apr 2020 15:30:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/manipulando-dados-de-um-site-com-web-scraping/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/manipulando-dados-de-um-site-com-web-scraping/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
  </channel>
</rss>
