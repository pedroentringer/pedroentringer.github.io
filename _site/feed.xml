<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Um tanto quanto curioso</description>
    <link>https://pedroentringer.dev//</link>
    <atom:link href="https://pedroentringer.dev//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 01 May 2020 14:44:06 -0300</pubDate>
    <lastBuildDate>Fri, 01 May 2020 14:44:06 -0300</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Criando seu plugin para Google Chrome</title>
        <description>&lt;p&gt;Heeeey, já vimos que na internet tem vaaaarios tutoriais sobre este tema, não é mesmo?
Vamos pra mais um, só que dessa vez, sem &lt;strong&gt;pop-up&lt;/strong&gt; hahaha.&lt;/p&gt;

&lt;p&gt;Ah, e esse plugin vai funcionar no Google Chrome, Opera e no novo Edge.&lt;/p&gt;

&lt;p&gt;O que nós vamos fazer por aqui é explorar aquele menu que aparece nos sites quando clicamos com o botão direito do mouse. Iremos criar uma opção para compartilhar um texto selecionado com algum contato do &lt;strong&gt;WhatsApp&lt;/strong&gt; que for definido no script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/5d73b650-3a82-4487-b133-a66217e0a7a7.png&quot; alt=&quot;Menu do navegador&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lets-go-to-code&quot;&gt;Let’s go to code&lt;/h3&gt;
&lt;p&gt;Vamos iniciar nosso projeto com uma pasta em branco, e nela criaremos o primeiro arquivo chamado &lt;strong&gt;manifest.json&lt;/strong&gt;. Este arquivo contem todos os detalhes de nossa extensão e eu vou explicar os mais importantes agora.&lt;/p&gt;

&lt;p&gt;Vamos colocar nele essas configurações:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;background&quot;: {
    &quot;persistent&quot;: false,
    &quot;scripts&quot;: [&quot;src/index.js&quot;]
  },
  &quot;browser_action&quot;: {
    &quot;default_title&quot;: &quot;Compartilhamento do Pedro&quot;,
    &quot;default_icon&quot;: &quot;icon.png&quot;
  },
  &quot;icons&quot;: {
      &quot;128&quot;: &quot;icon.png&quot;,
      &quot;16&quot;: &quot;icon.png&quot;,
      &quot;32&quot;: &quot;icon.png&quot;,
      &quot;48&quot;: &quot;icon.png&quot;
  },
  &quot;description&quot;: &quot;Compartilhar frases e sites&quot;,
  &quot;manifest_version&quot;: 2,
  &quot;name&quot;: &quot;Compartilhamento do Pedro&quot;,
  &quot;permissions&quot;: [&quot;contextMenus&quot;],
  &quot;short_name&quot;: &quot;Compartilhamento do Pedro&quot;,
  &quot;version&quot;: &quot;0.1&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos ver melhor o que significa isso:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;background&lt;/strong&gt;: aqui ficam as configurações de segundo plano, ou seja, aquilo que vai acontecer por tras da tela.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;persist&lt;/strong&gt;: definimos que não vamos salvar nada, ou seja, não iremos persistir nenhum dado.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;scripts&lt;/strong&gt;: e aqui vem o principal, serão os nossos arquivos de javascript que irão manipular o menu.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;browser_action&lt;/strong&gt;: aqui ficam as configurações mais visuais como icone e titulo que irão aparecer no menu.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;permissions&lt;/strong&gt;: Este passo é muito importante, pois sempre precisaremos deixar claro as permissões que desejamos usar. E para o nosso tutorial precisaremos apenas do &lt;strong&gt;contextMenus&lt;/strong&gt;, mas você pode ver as outras &lt;a href=&quot;https://support.google.com/chrome/a/answer/7515036?hl=pt-BR&quot; title=&quot;Permissões de Aplicativos e Extensões&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Feito isso vamos colocar um icone na extensão né, e pode ser na raiz do projeto mesmo, no meu caso vou por minha foto de perfil hahahah.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lembre-se&lt;/strong&gt; de colocar o arquivo com o mesmo nome e extensão que foi inserido no &lt;strong&gt;manifest.json&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;cadê-o-código&quot;&gt;Cadê o código?&lt;/h4&gt;
&lt;p&gt;kkkk eu sei, eu sei. Falei demais. &lt;strong&gt;bora codar&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Crie uma pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; e um &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; nela e vamos entender duas coisas. A instalação e as funcionalidades.&lt;/p&gt;

&lt;h5 id=&quot;instalação&quot;&gt;Instalação&lt;/h5&gt;
&lt;p&gt;Sempre que você instala uma extensão o chrome vai executar uma função chamada &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.runtime.onInstalled&lt;/code&gt;. E é essa função que iremos usar para criarmos os nossos menus.&lt;/p&gt;

&lt;p&gt;Pra começar vamos definir quais serão os nossos menus, dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
  {
    id: 'numero01',
    title: 'Compartilhar com a pessoa 01'
  },
  {
    id: 'numero02',
    title: 'Compartilhar com a pessoa 02'
  }
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show, agora vamos entender como vai funcionar esse onInstalled do chrome.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onInstalled = () =&amp;gt; {
  //essa função vai executar sempre que a extensão for instalada
}

chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bom, se já temos uma função que vai ser executada logo de inicio, é nela que iremos criar nossos menus. E vamos fazer isto usando uma outra função do chrome que é a &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.create&lt;/code&gt;, então vamos percorrer todos os nossos menus e cria-los.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
  {
    id: 'numero01',
    title: 'Compartilhar com a pessoa 01'
  },
  {
    id: 'numero02',
    title: 'Compartilhar com a pessoa 02'
  }
];

const onInstalled = () =&amp;gt; {

  for (const menu of menus) {

    chrome.contextMenus.create({ 
      ...menu, 
      contexts: ['selection'], 
    })
        
  }

}

chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reparou que o &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.create&lt;/code&gt; recebe um &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; como parâmetro? É isso que são os menus do chrome hehehe.&lt;/p&gt;

&lt;p&gt;Nós ainda passamos um array de &lt;strong&gt;contexts&lt;/strong&gt; pra essa função, e pra que isso server? É aqui onde definimos quando o menu aparece. Usando o context &lt;strong&gt;selection&lt;/strong&gt; estamos dizendo que o menu vai aparecer sempre que selecionarmos um texto em algum site e clicarmos com o botão direito.&lt;/p&gt;

&lt;p&gt;Você pode ver todos os contexts permitidos &lt;a href=&quot;https://developer.chrome.com/apps/contextMenus#type-ContextType&quot; title=&quot;Contexts&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se testarmos essa extensão agora, já vamos conseguir ver nossos menus por lá:
&lt;img src=&quot;/assets/images/posts/12028790-eb93-4015-aaee-252a8bf74dc8.png&quot; alt=&quot;Menu do navegador com as nossas opções&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;funcionalidade&quot;&gt;Funcionalidade&lt;/h5&gt;
&lt;p&gt;Shoooow, já chegamos até aqui! Agora é mole demais!&lt;/p&gt;

&lt;p&gt;Pra adicionar funcionalidade ao clique em nosso menu iremos usar a outra função do chrome que é a &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.onClicked&lt;/code&gt; e o nosso código vai ficar mais ou menos assim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onClicked = (data, tab) =&amp;gt; {
    const { menuItemId, selectionText} = data
    alert(`Selecionou o texto &quot;${selectionText}&quot; para compartilhar com &quot;${menuItemId}&quot;`)
}

chrome.contextMenus.onClicked.addListener(onClicked)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora sempre que selecionarmos um texto e usarmos nosso compartilhamento o navegador vai mostrar isso em um alerta hehehe
&lt;img src=&quot;/assets/images/posts/e7e74506-a182-4dc7-9983-96078f8cb539.png&quot; alt=&quot;Menu do navegador com as nossas opções&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas é só isso?&lt;/strong&gt; kkkkkk Calma. Vamos de fato compartilhar o texto!&lt;/p&gt;

&lt;p&gt;Então agora é simples, já temos o texto e o numero da pessoa, então é só fazer o redirect pra url do &lt;strong&gt;WhatsApp&lt;/strong&gt; usando outro recurso do chrome chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.tabs.create&lt;/code&gt; que irá criar uma aba no navegador com a url que passarmos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onClicked = (data, tab) =&amp;gt; {
    
    const { menuItemId, selectionText} = data
    
    const resource = new URL(&quot;https://api.whatsapp.com/send&quot;)
    resource.searchParams.append('phone', menuItemId)
    resource.searchParams.append('text', selectionText)

    chrome.tabs.create({ url: resource.href })

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E se você fez tudo certinho seu plugin já estará funcionando perfeitamente!!!&lt;/p&gt;

&lt;p&gt;Claro que esse exemplo é bastante simples, e você provavelmente não irá usar para nada, mas o que vale é entender o funcionamento de extensões do chrome.&lt;/p&gt;

&lt;p&gt;Aqui no trabalho nós usamos uma extensão semelhante a essa pra poder consultar pedidos diretamente do e-mail sem precisar ficar abrindo o sistema toda vez. Ah, e a extensão foi criada dessa mesma forma.&lt;/p&gt;

&lt;p&gt;O código completo ficou assim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
    {
        id: 'pessoa-01',
        title: 'Compartilhar com a pessoa 01'
    },
    {
        id: 'pessoa-02',
        title: 'Compartilhar com a pessoa 02'
    }
];
  
const onInstalled = () =&amp;gt; {

    for (const menu of menus) {

        chrome.contextMenus.create({ 
        ...menu, 
        contexts: ['selection'], 
        })
            
    }

}

const onClicked = (data, tab) =&amp;gt; {

    const { menuItemId, selectionText} = data
    
    const resource = new URL(&quot;https://api.whatsapp.com/send&quot;)
    resource.searchParams.append('phone', menuItemId)
    resource.searchParams.append('text', selectionText)

    chrome.tabs.create({ url: resource.href })

}

chrome.contextMenus.onClicked.addListener(onClicked)
chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 01 May 2020 04:20:00 -0300</pubDate>
        <link>https://pedroentringer.dev//nodejs/criando-seu-plugin-para-google-chrome/</link>
        <guid isPermaLink="true">https://pedroentringer.dev//nodejs/criando-seu-plugin-para-google-chrome/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Trabalhando com argumentos em Node.js</title>
        <description>&lt;p&gt;Você já fez aquele programa que executa uma tarefa específica e que funciona perfeitamente, dai de repente surge a necessidade de que esse programa receba um parâmetro ao iniciar? &lt;strong&gt;Provavelmente sim&lt;/strong&gt;, mas caso ainda não tenha passado por isso, vale a pena aprender pois uma hora você irá acontecer.&lt;/p&gt;

&lt;p&gt;Vamos supor que ele precise receber um CNPJ no início do programa, por algum motivo do destino, talvez pra buscar os dados em alguma API. O que importa agora pra gente é entender como usar os argumentos.&lt;/p&gt;

&lt;p&gt;Naturalmente o Node.js nos permite acessar argumentos no início do programa, então vamos supor que eu deseje passar dois parâmetros, sendo eles &lt;strong&gt;cnpj&lt;/strong&gt; e &lt;strong&gt;isActive&lt;/strong&gt;, eu faria dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node index 123 true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E lá no código, eu precisaria acessar esses parâmetros da seguinte maneira:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const cnpj = process.argv[2]
const isActive = Boolean(process.argv[3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Funciona&lt;/strong&gt;? Sim, funciona. Mas você percebe que tanto a forma de passar esses argumentos quanto a de recebe-los ficou estranha? Talvez não agora, mas no futuro certamente irá ser. Imagine uma outra equipe dando manutenção nesse código dois anos depois.&lt;/p&gt;

&lt;p&gt;Pois é, eu passei por isso a um tempo atrás, e por este motivo fiz a lib &lt;strong&gt;@pedroentringer/parser-command-line&lt;/strong&gt; que simplifica muito este processo.&lt;/p&gt;

&lt;p&gt;Então vamos instalar esse trem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add @pedroentringer/parser-command-line&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sensacional, feito isso já podemos passar e receber argumento de uma forma muito mais simples.
Usando o mesmo exemplo ficaria dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node index --cnpj=123 -isActive&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Melhorou né? Agora veja como faremos pra acessar isso no código:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const parser = require('@pedroentringer/parser-command-line')
const args = parser.parseArgs();

console.log(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que tanto a chamada do script quanto sua escrita ficaram muito mais simples né? Eis o resultado disso:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  bin: &quot;node&quot;,
  commands: [&quot;index&quot;],
  flags: {
    cnpj: 123,
    isActive: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dessa forma fica muito melhor pra gente usar estes dados não é mesmo? E melhor ainda, você pode usar essa lib na web também, dessa forma é possível fazer o parse de um comando vindo de uma string. Pense que a ordem veio via websocket do backend, ou qualquer outro cenário hehehe.&lt;/p&gt;

&lt;p&gt;Usaríamos assim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const parser = require('@pedroentringer/parser-command-line')
const args = parser.parseString('meuPrograma show --message=&quot;Que legal, isso é uma mensagem&quot; --time=100 -isSuccess');

console.log(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e o resultado desse parse será:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  bin: &quot;meuPrograma&quot;,
  commands: [&quot;show&quot;],
  flags: {
    message: &quot;Que legal, isso é uma mensagem&quot;,
    time: 100,
    isSuccess: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Apr 2020 10:00:00 -0300</pubDate>
        <link>https://pedroentringer.dev//nodejs/trabalhando-com-argumentos-em-nodejs/</link>
        <guid isPermaLink="true">https://pedroentringer.dev//nodejs/trabalhando-com-argumentos-em-nodejs/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Manipulando dados de um site com Web Scraping</title>
        <description>&lt;p&gt;É impressionante a ideia de conseguir manipular os dados de um site de outra pessoa não é mesmo? Eu adoro isso, logo quando comecei a faculdade de programação fiquei intrigado por não ser a primeira coisa a aprender (que sonho).&lt;/p&gt;

&lt;p&gt;Mas vamos direto ao ponto, aqui vamos aplicar o Web Scraping em um site simples e em outro um pouco mais complexo. &lt;strong&gt;Let`s go to code&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;bibliotecas-utilizadas&quot;&gt;Bibliotecas utilizadas:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Cheerio&lt;/li&gt;
  &lt;li&gt;@pedroentringer/cheerio-table-parser &lt;strong&gt;(Mágica kkk)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Axios&lt;/li&gt;
  &lt;li&gt;Puppeteer&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manipulando-dados-de-um-sitesimples&quot;&gt;Manipulando dados de um site simples&lt;/h4&gt;
&lt;p&gt;Pra começar vamos criar nosso projeto bem rapidinho&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn init -y
$ yarn add cheerio axios puppeteer @pedroentringer/cheerio-table-parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este processo pode demorar alguns minutinhos para terminar, enquanto isso vamos falar um pouco sobre cada uma dessas dependências.&lt;/p&gt;

&lt;h5 id=&quot;axios&quot;&gt;Axios&lt;/h5&gt;
&lt;p&gt;O Axios é muuuito usado para fazer requisições HTTP, quando você quer buscar ou enviar dados para algum site.
Por aqui vamos usar ele para buscar a estrutura do meu próprio blog hehehe&lt;/p&gt;

&lt;h5 id=&quot;cheerio&quot;&gt;Cheerio&lt;/h5&gt;
&lt;p&gt;O Cheerio é uma lib que nos permite manipular a DOM do site com mais facilidade, muito similar com a forma do JQuery.&lt;/p&gt;

&lt;h5 id=&quot;pedroentringercheerio-table-parser&quot;&gt;@pedroentringer/cheerio-table-parser&lt;/h5&gt;
&lt;p&gt;Essa é uma lib que eu mesmo fiz pra resolver uma problema que eu tive recentemente. Ela basicamente recebe qualquer tabela em HTML e converte para JSON, assim fica mais fácil de manipular os dados né? hehehe&lt;/p&gt;

&lt;h5 id=&quot;puppeteer&quot;&gt;Puppeteer&lt;/h5&gt;
&lt;p&gt;O Puppeteer é incrível, com ele você consegue mapear ações para que um “bot” replique no site usando um navegador, como se fosse uma pessoa de verdade, &lt;strong&gt;top né?&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;lets-go-to-code&quot;&gt;Let’s go to code&lt;/h5&gt;
&lt;p&gt;Depois que tudo tiver instalado certinho, bora começar de uma forma simples.
O desafio vai ser buscar o titulo do primeiro post desse nosso blog aqui.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar nosso primeiro arquivo &lt;strong&gt;index.js&lt;/strong&gt; e já importar o &lt;em&gt;axios&lt;/em&gt; e o &lt;em&gt;cheerio&lt;/em&gt; nele&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const axios = require('axios')
const cheerio = require('cheerio')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Show, feito isso já podemos usar o axios para fazer uma busca na home do nosso blog, e vamos fazer isso da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const webscraping = async () =&amp;gt; {

  //Busco os dados no site, e aqui vou receber todo o HTML dele
  const { data } = await axios.get('https://pedroentringer.dev')

  //Importo isso para o cheerio
  const $ = cheerio.load(data)

  //Busco todos os elementos de link &quot;a&quot; que sejam filho de elementos que possuem a classe &quot;post-title&quot; 
  const posts = $('.post-title a')

  //Pego apenas o primeiro elemento
  const firstPost = posts.first()

  //E taraaaam, exibo o texto que tem nesse elemento
  console.log(firstPost.text())

}
webscraping()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E o resultado disso será:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Manipulando dados de um site com Web Scraping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simples né? Agora vamos complicar um pouco mais.&lt;/p&gt;

&lt;h4 id=&quot;manipulando-dados-de-um-sitecom-autenticação-e-navegação&quot;&gt;Manipulando dados de um site com autenticação e navegação&lt;/h4&gt;
&lt;p&gt;Agora imagine um cenário que você precise fazer um projeto freelancer pra uma empresa que possui um e-commerce em Magento 1.9, eles precisam visualizar facilmente os 5 pedidos mais populares do site.&lt;/p&gt;

&lt;p&gt;Nesse caso, a cada pagina do painel é gerado um token diferente, e seria bem chato ficar adivinhando como ele gera esse token para que possamos reproduzir da mesma forma, né? Maaas, para resolver isso nós podemos acessar esses dados usando um navegador, e é ai que entra o puppeteer.&lt;/p&gt;

&lt;p&gt;Vamos lá, importaremos todas as libs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import cheerio from 'cheerio'
import parseTable from '@pedroentringer/cheerio-table-parser'
import puppeteer from 'puppeteer'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que substituímos o axios pelo puppeteer.
E agora é só abrir o navegador, acessar o site, e &lt;strong&gt;daaaale&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const webscraping = async () =&amp;gt; {

  //Com o puppeteer eu chamo um navegador
  const browser = await puppeteer.launch({
    headless: true //Aqui eu defino se quero que ele apareça ou não =&amp;gt; true (não aparece) | false (aparece)
  })

  try {

    //Crio uma nova aba no navegador
    const page = await browser.newPage()

    //Acesso a pagina de login do painel
    await page.goto('meu_site/admin')

    //Insiro meu email no input de login
    await page.type('input[id=username]', 'oi@pedroentringer.dev')

    //Insiro minha senha no input do login
    await page.type('input[id=login]', 'minha_senha')

    //Clico no botão de Entrar
    await page.click('input[type=submit]')

    /**
    *  Agora eu preciso aguardar o site carregar
    *  e o elemento com id #grid_tab_reviewed_products aparecer na tela
    *  
    *  No painel do Magento 1.9 esse elemento representa um botão que 
    *  irá carregar na tela uma tabela com os 5 produtos mais visitados no site
    *  
    *  Assim que ele aparecer eu clico nele
    */
    await page.waitForSelector('#grid_tab_reviewed_products', { visible: true, timeout: 0 })
    await page.click('#grid_tab_reviewed_products')

    /**
    * Apos o clique, preciso esperar nossa tabela aparecer, pois o Magento irá fazer um request e buscar esses dados
    */
    await page.waitForSelector('#productsReviewedGrid_table', { visible: true, timeout: 0 })

    /**
    * Perfeito, agora que chegamos aqui, é como se estivessemos naquele exemplo simples
    * Basta pegar o html da pagina e manipular com o cheerio
    */
    const html = await page.content()

    //Lembre-se sempre de fechar o navegador kkk
    await browser.close()

    //Importo o HTML do site atual para o cheerio
    const $ = cheerio.load(html)
    
    //Ativo o modulo de converter a tabela
    parseTable($)

    //converto a tabela para JSON
    const table = $('#productsReviewedGrid_table').parseTable()

    console.log(table)

  } catch (err) {
    await browser.close()
    console.error(err)
  }
}
webscraping()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O mais legal é o resultado super fácil de manipular, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
  {
    nome: 'Camiseta Infantil Ac/Dc Preta',
    preco: 'R$ 42,90',
    visitas: 185
  },
  {
    nome: 'Body Beatles Yellow Submarine Manga Curta Branco',
    preco: 'R$ 39,90',
    visitas: 178
  },
  {
    nome: 'Body Iron Maiden Manga Curta Preto Algodão',
    preco: 'R$ 39,90',
    visitas: 170
  },
  {
    nome: 'Body Manga Curta Chega De Nana Neném Preto',
    preco: 'R$ 39,90',
    visitas: 144
  },
  {
    nome: 'Body Ac/Dc Manga Curta Preto',
    preco: 'R$ 39,90',
    visitas: 141
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Apr 2020 15:30:00 -0300</pubDate>
        <link>https://pedroentringer.dev//nodejs/manipulando-dados-de-um-site-com-web-scraping/</link>
        <guid isPermaLink="true">https://pedroentringer.dev//nodejs/manipulando-dados-de-um-site-com-web-scraping/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
  </channel>
</rss>
